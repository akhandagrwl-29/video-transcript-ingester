hi everyone welcome to the new system design video on event-driven architecture so as you can see we have a set of services with us the main difference between request response and event or in architecture is that you have requests sent by clients to our gateway services but internally what happens is these services never interact with each other directly instead they use events to state that yes something has changed so if a service is sending an event to the event bus it's basically saying something is happened which it concerns me and if it concerns anyone else you can consume this event so all interested consumers which can be called subscribers and this can be called the producer consume this event and see if this el event is relevant to them after that they might create events themselves because their internal state might change so on and so forth down this tree up to this service which might be sending an email to another client now I kept this email bit because it gets interesting with this for now just remember that this is very similar to publish a subscriber but some subtle differences coming in after some time once I explain what the applications are because looking at these architectures you might wonder why would I ever use this the most popular event-driven architecture that I can think of is gate gate uses events which are like commits to get its way through its history there's a react which is if you're a JavaScript pan then react is something that you probably know about nodejs if you are on the server side and many gaming systems also use event-driven architecture speaking of games there's a really interesting use case where event-driven architecture has come into play let's say you are the first player and there's a second player and there's this server in between and these are your timelines so in a first-person shooter game like counter-strike you know about the headshots that we can take let's say you you look at a person and you're at this point and you click you're your headshot so this information goes to the server the server then figures out where player two exists and maybe player two is at position 10 and while you take took the headshot you saw the player at position 9 after evaluating whether it's a headshot or not which it does not the server says no this is not a headshot but the thing is at this point in time T maybe 2 was at position 9 so if 2 was at position 9 this should have given a headshot to 2 and you should have won the game but instead what has happened is because we had a delay response maybe to move to position 10 told that to the server and the server has updated its position because of this movement but that's not fair because you know you took the headshot when the player was at position 9 and you're getting position 10 you want headshots so what you can do here is as the server take these new movements or shots as events and when you have an event-driven architecture this is quite easy you just take the event you take the timestamp whenever required you can move back that is one way you can undo or you can replicate all the ones that you had up to this point you know you pass the timestamp of let's say 50 and you just move 50 events forward check this state if player 2 as a is at position 9 then you call that a headshot and you win the game in a system design question though there's very specific areas where you might find a mentor in architecture useful if you're not able to get them into an architecture working you know quickly enough or if it's if it's not fitting into the model don't pursue it and we'll get back to this in some time the reason why it's not it's not very flexible so as you can see there's a lot of places where even driven architecture can come into play the workings of this thing are explained right now so let's say this is service one service to service 3 and service for so service 1 gets a request it sends an event over here it's in the event bus now when service 2 gets this event it actually stores that event in its own local database and this is one of the important things about given to an architecture each of the services stores the data it's getting from this event bus it's not compulsory necessarily I mean it can be a single store of data also the event bus can store all the data but you usually want to pass this persistence requirement to the services which are actually consuming this event because then the event bus can be free it can get rid of the events it doesn't even need to take care of persisting them in the right way the service can store these events by adding additional fields which are relevant to it or maybe removing some other fields which are not relevant to it but it stores them in the local database and so even if this service is not working the second service doesn't need to ask relevant information every time so this is a little different from the standard micro-service architecture that we have where all the services store data only is relevant to them sure you're storing data which is relevant to you but also coming from other services so the database is actually storing event information now what are the advantages of this one like we said is availability even if some service goes down you don't need to ask it for relevant events so you are available although with high availability comes one straight off problem which is consistency so if the data here has changed like over here then this data needs to get updated according to this data that usually doesn't happen and that's why consistency is not so good consistency is simply all of your data across all of your services being the same that is consistent and this won't be consistent what other good thing can be done by just storing all the events so if you have something like the event log which is basically what your database is doing it's logging all of the events you can actually move to any point in history using this event log so going from the start to a particular point is very easy you just run the events one by one and you are at that state so if you have any bug in your code which you know came after a timestamp T just go to that timestamp T run one event one by one and you can actually debug it even for a production system so that's a big advantage of event-driven architecture let's say you write a new service service v which needs to replace service two it's very easy all you need to do is ask the event bus to send you all the new ends before that you take all the events from x time 0 to time stamp whatever the current time stamp replay these events into this service and service 5 will be consistent with service 2 then and then you have already accepted the newer events and this service will be online so it can replace service two very easily it's a smooth replacement instead of the clunky bits that we have in in one event-driven architectures okay two more advantages of this the first one is that it gives you a transactional guarantee messages when sent to any service are either at least one or at most one in this architecture so if it is at most one then you send a message and you don't care if it reaches or not if it doesn't reach it's fine maybe sending the email is not so important so at most one might be a welcome email on the other hand if it's an invoice email you want it to be sent definitely so that is at least one in which case you will be retrying your event bus logic in case the service doesn't get it try again try again but definitely send the email at least once so it's giving you that kind of transaction guarantee and finally when you're storing these events which are which is basically the relevant data to you you are also storing the intent of the event why did you change that data now because of this tomorrow if you have a new service you can actually look at the intent of the data and make changes in your code such that you have a completely different state in your service file finally it will be storing all the events of course but the actions it performs depends on the events only so if you have all the events logged with you you can actually do different actions compared to service two enough of that Vantage's in how let's get better at disadvantages service for is a point of interest it's sending emails to external services and in this event-driven architecture you might think that I can replace service for just like I replace service to but we can't because when we has any emails we are dependent on responses from external systems and if that response is dependent on time then when we are trying to actually replace this service by replaying all the events those events will get different responses so its behavior will change without us actually wanting it to that's one major issue with event-driven architectures all the services on the Gateway will need to be storing the timestamp of the responses sometimes that's ok but sometimes the responses are entirely dependent at a time and you know storing the timestamp and the response doesn't make any sense sometimes other thing is it's not it's not giving you too much control whenever we are sending and I went to the event bus and it's sending it to service two or service three we really don't have that fine-tuned control of a request and response with a request and response we can clearly mention how much time the request should take exactly the service you want to send it to with this it's dependent on the event bus and even if you can mention to the event bus in how many seconds it should be done that event might not come into the queue till quite some time and if you were to get over that then you have to set priorities things are getting complicated because we cannot fine-tune the handling of these events what should be an event if there's any interstate which has changed for me and it published that all the time is an event maybe that's a security issue maybe I don't want that data published outside but an event bus architecture it's difficult to know what people want to consume and what people don't want to consume the problem with this also is that maybe you want some services to consume your events and you want to stop some other services from ever touching your wins that brings an additional layer of complexity to the event bus I'm not saying that it's impossible it's just really difficult to do this another disadvantage is that if it's storing all the events one by one and you need to get to a particular point sometimes there's only three ways the first one is to replay from start and this is replaying the entire system of course it's completely impractical for many of the systems because there's too many events that you need to process the second one is diff based in which case you take the first event and then just store the diffs and the third one is to use something like an undo so this is really cool you can undo up to a particular point but some operations can be undone some operations cannot be undone like subtractions and additions yeah you can you can undo them but there are some operations which you cannot undo this like for example sending an email one way that you can get rid of it is to squash all events so compaction every maybe day or two days or three days you can compact all the events up to a particular day instead of up to a particular time stand so that will really help the system because you can roll to that point so if based or then replay is also going to work so that's just a disadvantage which can be overcome so it's not really so much of a disadvantage by now you might be feeling a little apprehensive about using this architecture so I'll give you two more disadvantages both of them are developer or the scientist is that software teams feel the first one is that it's difficult to reason about the flow of this system when you look at service one so this one is just publishing to an event bus but then that's where it code stops looking at service once cold you can just figure out that the AI publishes to an event bus but you don't know what happens with that event so you have to go to the event bus and see what are the subscribers for this event so the flow of the program is not easy to understand that's a major problem with designing these kind of systems the developers will not be looking able to look into the code and figure out where the things are going the second thing is it's difficult to move out of so if you have this kind of architecture and you suddenly want some part of it to be a request response architecture it's not so easy because everything is an event you're going to be consuming that and then passing that forward if you send it as a request to one of the event buses it is possible but it's not going to fit very well in conclusion we can think of services in event-driven architectures to be having some sort of a log of their events and using a publisher subscriber model to pass and consume those events a good way to actually remember all that Vantage's and discern disease of this is to think of what event-driven architectures are all the services in an event or in architecture they publish events when they feel like someone needs to know something so they publish an event while in the request response so service asks for something so that might be data it might be a service that's the primary difference between these two architectures and almost all of the advantages and the disadvantages come from this subtle point like I said a lot of systems actually use this architecture small talk and get I think are the oldest ones which use this while react and nodejs are the popular new ones who choose this architecture if you want to have a discussion on all those things then we can have them in the comments below if you want to subscribe or for the video similar to this please press the subscribe button and you can always like the video of course I'll catch you next time you 