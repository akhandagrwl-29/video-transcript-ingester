hi everyone this is gkcs today we are talking about the Master Slave architecture and what I'm going to be doing is talking about a scenario which ends up with us using the Master Slave architecture to solve the problem right and this is the problem the problem is that we have four cell phones as you can see and you have a load balancer which is going to be redirecting these requests from the cell phones to our servers now this is a very common diagram so to speak in interviews that people draw lots of servers but they have just one database so whenever you see a single thing like this load balancer or this database the first thing that should strike you is that this is a single point of failure so when you're seeing a database it can crash now if it does crash then your business stops because everything all the requests depend on data in the servers which is being pulled from the databases basically So to avoid that kind of a problem there's many things you can do but the simplest solution so to speak is just to replicate the data that you have in that database and store it some somewhere else right just have a copy so that's what we're going to do we are just going to make a copy this copy is preferably stored in some other Hardware component yeah because if that Hardware crashes then you shouldn't have the copy also crashing so I'm assuming that it's in some of raid card so so now that you have this copy how are you going to pull data from this original database there's two ways mainly synchronously or asynchronously if it is asynchronously the good thing is there's not too much load on the database over here you know there's not somebody continuously asking for an update every time there is an update on the original database so that's one advantage one disadvantage of that is it's going to be out of sync yeah that's what asynchronously means so if there is a transaction let's say in the original one in this database it may not reflect in this one before it crashes so in that case you're going to have some sort of inconsistent data but maybe that's okay maybe you can do you can deal with that so asynchronous is good for you if you can't then you're looking for something called synchronous copies the thing with synchronous copies is you know there's no such thing as a synchronous copy so to speak unless it's enforced by human beings through code what's going to happen is whenever there's an update on the original database it's going to be sending a message to this guy over here that hey I got an update and in your transaction log you can make this change you can add this command so for example add 100 to user ID one is a command that the master got yeah finally we're getting into the technical terms this is the master and this is the slave you can probably guess the kind of roles that they have so the master gets the command and it sends it to the slave to be copied so all the slave needs at any point of time is a command and it can just rerun this command to have the same consistent State as the master because all the commands are the same and in the same serial order that's an assumption that I'm making here here's an interesting thought what if one of the servers wants to update the slave so S3 sends an update command to the slave I'm going to be adding 200 Rupees to user ID to if this is the case the slave needs a way to tell the master that there's a change and that has to be propagated upwards there's two ways to solve this problem uh and the first way is to just ignore the problem or to just never let the problem happen so the way you can do that is to never allow right operations to come over here yeah so this operation is impossible the slave never gets any right operations it just copies data the second thing you can do is actually allow this allow that add 200 to user ID too and propagate this to the master in this case the slave has actually taken over the role of the master uh and it's no longer a a Master Slave relation but it's a peerto pure relation in which case both of them are Masters the key Point here is that the master is the only person who can take right operations so any any database copy which is taking in right operations is a master so over here we have a master master architecture now in a master master architecture what's going to happen is you'll have some propagation like we said so there's going to be back and forth between the two nodes now this seems really nice it feels like these two databases are equal and uh you know there's right operations happening on both of them so there is some load balancing on the right operations also uh and the best thing about this fields that you know what happens if this database crashes no problem everyone can redirect their requests to this database uh and if this one crashes then of course they can do vice versa and so it seems like a very resilient and strong system uh however there's a problem and the problem is in a distributed system nothing is sure because of the network partition thing because of communication can fail so if a and b are both Masters and they talk to each other and they make sure that they are in sync if B fails our assumption is that a will take up the role uh of the entire database right what happens if B has not failed but the router between them has failed yeah they were sending a message uh this router had some issue so now they're unable to send messages to each other in this case a assumes that I'm the master I know everything about the world so I'm going to be accepting read and write operations and that's okay and that's exactly what B also assumes you know B thinks that I'm the master I'm going to be taking read and WR operations and you know what's going to happen over here um if user user X sends a message to deduct 100 rupees from their account uh and then they send another message over here to deduct 50 rupees from their account and let's assume that they have a balance of 120 so in a balance of 120 they actually deducted 10050 so they actually went into negative balance this problem is called the split brain problem yeah when you split your brain interestingly the split brain problem can be solved by adding a third node to the original architecture so A and B had problems with the split brain uh if you add in C then you can solve the problem so to speak uh it's just that it's based on assumption and the assumption is this that the chance of a node crashing and the router between the other two nodes crashing is highly highly unlikely so we're going to assume it never happens so what could possibly happen uh if C crashes then A and B are Masters and they are staying in sync they are sending messages to each other and making sure that the world is in a consistent State for the two of them so that's fine and when C comes back up they can read from A or B when the link between A and B goes down which is the basis of the split brain problem what happens a gets a right request so that that sends the state of a into let's say x um it propagates the state to C it tries to propagate the C uh state to B but it's not it's not allowed so initially the state is s0 s0 and s0 it moves to State X so now the state is SX and over here the state has moved to SX b gets the right operation it's state moves to s y it tries to propagate this state to C but that doesn't happen the reason it doesn't happen is because C says what's your previous state so from s0 it went to s y uh C sees that this is this is not the same state as I am in which is SX and what it can say is hey B you need to update your state you need to update your state to this and then you can have a successful transaction so then B's transaction can fail and instead of moving to s y it rolls it back it's a roll back on the transaction and it syns up with SX right and at this point what can happen is the user is fine the transaction did not go through so that's expected and they can send the request again with the newer State SX B can then run the transaction reach the state syy ask C to go there and now a when it gets a new transaction let say sending it to Z can have the same procedure with it there's lots of interesting scenarios here of course what happens if B sends a request to C to update itself and it crashes with the with the new estate well it can't have this state permanently because it's a transaction it can roll it back before it's committed only after all other nodes have actually committed the transaction can you call this to be the state of this node so I've just used it for representational purposes the other thing you can think here is that a can never make a transaction which doesn't have the updated state from B also because that is being propagated by C and we are assuming that either one router or one node fails you know two things don't happen at the same time as you can see this is heading into the land of distributed consensus and I'll be speaking on this when you guys uh vote for this topic so take your time and there's other topics also but yeah we can speak on this when you like uh distribute consensus is a way in which multiple nodes agree on a particular value and that's what's happening over here B A and C are agreeing at the final state which is s right uh and there's many protocols you have for distribute consensus um I have tried to simplify it over here uh there's if you have lots of nodes then 2pc is a very popular protocol although there's some serious drawbacks here that it's really slow two-phase commit you can read up on that uh there's three-phase commit one interesting protocol which I really like is mvcc uh which is multiversion congruency control it's a long name but it's used by post Grace the good thing about mvcc is that as you can see multiversion that means that it keeps multiple versions of the same data so if I send multiple update commands on the same data it keeps multiple copies yeah the reason for this is that depending on your requirement uh it behaves in a certain way so if you're okay with dirty reads then it's going to keep a older version of the data and someone can go and read it but if you say that no I want really nice serializable reads no Phantom reads and all that then it's going to of course make it slower but it's going to ensure that that data is consistent with everything else okay it might be heavy uh to understand so but have a look at mvcc it's a really nice way way to uh get some sort of lock on the data another interesting uh protocol used by Microsoft for the game Halo is Saga yeah this is Saga as you can think of is a long transaction so it's like a long story I'll give you a few examples on Saga um let's say you have a food ordering app and a person makes an order now the restaurant has not actually agreed on that order so the transaction is not really complete so to speak uh they may not have withdrawn the funds what they want to do is lock your funds so if you have made an order for 200 rupees they go to your bank and say lock these 200 rupees uh from my customer until I get a confirmation I'm actually not going to withdraw this money if the transaction fails then I'm going to just keep the money you know you don't need to go through the whole transaction process and settlements at the end of the day and everything this is one use case uh the Second Use case is if you have a phone app right uh and a person makes a call so you need to charge the person but the thing is it might last for 30 minutes so you can break it into smaller transactions of 1 minute each in which you you're not going to charge the customer but you're going to lock funds every minute a little more and a little more and at the end of the thing you're going to decide whether the call is a failure or a success and based on that you're going to charge the customer okay so that's a saga a really long transaction which at any point can fail and you may need to roll it back okay uh interesting concept we'll be talking about that when we we do get to distribute consensus I think I'm really pushing very hard for this topic now now enough of all the negative things that we can think about in The Master Slave architecture uh why would you ever go for this kind of an architecture the first reason is that you have this nice replica of the data so that's backup the second thing is that you can scale out your read operations so if you have to do some sort of analytics you don't really care about real time so much you can keep pulling data from the master to the slave and then you can run some sort of an analytics engine through the data another good thing over here is that you can add many slaves you can add maybe 10 slaves 20 slaves and just do read operations on all of them so if your data is not critical let's say Facebook you know you're adding a comment it doesn't really matter if it doesn't reflect immediately I mean it reflects on the master but the slaves will take some time to get that data you can make read operations on the slaves uh and basically scale out based on uh how many slaves you add to that one master and the final thing you can do to m this problem is to uh use a concept called sharding there's a video I made on that you can check it out through sharding what you're doing is you're breaking down your responsibilities to particular nodes so a is going to be handling users from 0 to 100 B is going to be handling users from 100 to 200 C is going to be handling users from 200 to all the way around to zero so it goes up to 300 and then basically hits zero what you effectively doing is you're reducing the range of the damage that you can have if one of the nodes fail so if node C fails uh then all the users between 200 and 300 are affected to mitigate that we can actually have a slave over here which will take up the role of a master when C crashes so you have some sort of coordinate over here when C crashes it points to C's slave which becomes the new master and then you can try to bring this node back up or add another node depending on what the requirement is but um what you have done effectively is using some sort of a 2pc protocol you can make sure that these two are in sync with each other always and if there is one failure your system will still work fine so as you can see there's lots of algorithms and a lot of thinking which goes behind making these systems reliable scalable and everything else um if you're looking for system design for your interviews you're probably also looking for a refresher course on your algorithms and here's the point when I actually place a product on my video uh this is algo expert it's actually extremely good more than anything if you are looking for a slightly senior role but also have some sort of algorithms answer this is a really good product I actually went through the questions that they have they 65 handpicked ones and they also have lots of explanations for each of these questions which includes the coding and the Whiteboard explanations the price for this is $65 uh either once or $20 a month so it depends on how much you can cram in but my suggestion would be if you do have some cash then go for the $65 option oh yeah by the way it's not 65 if you're going through this channel because you will be getting getting 30% off so that turns out to be 45.5 USD that's the discounted price you get if you use the promo code gorov so there's a link in the description below of course explaining the the pricing and everything else about algo expert the main thing I want to say is that I really like this site that's it on the Master Slave architecture uh I'm sure you have lots of doubts and suggestions so you can leave them on the comments below I'll answer as many as I can uh I take a poll every week for what do you want to see next so uh I'll be putting that in the community Tab and you can vote for what you want to see next as the video of course if you like this video then hit the like button and if you want notifications for further videos hit the Subscribe button I'll see you next time 